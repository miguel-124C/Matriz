unit UCMatriz;

interface
Uses SysUtils, Math;
const
     Nf = 128;
     Nc = 128;
Type

    Matriz = Class
      Private
             NroFilas,
             NroColumnas : Word;
             Celdas : Array[1..Nf,1..Nc] Of Real;
      Public
            Procedure Redimensionar(NF,NC:Word);
            Function Filas : Word;
            Function Columnas : Word;
            Function ObtElement(F,C:Word):Real;
            Procedure ModElement(F,C:Word; E:Real);
            Procedure AddFila;
            Procedure AddColumna;
            Procedure InsFila(F:Word);
            Procedure InsColumna(C:Word);
            Procedure DelFila(F:Word);
            Procedure DelColumna(C:Word);
            Function SumarElementos:Real;
            Function BuscElement(E:Real): Boolean;
            Procedure CargarMatriz (I,J: WORD; E: Real);
            Procedure CargarMtriz1 ;
            Procedure MatrizDeFibonacci;
            Procedure FormaDeCirculo;

            Function CountDig(E: Real):Byte;
            Function BuscarElementoPorFilas(E:Cardinal): Boolean;

            //-------------------------
            Procedure MatrizExamen;


            Function BuscPrI(I, J:WORD):WORD;
            Function BuscPrJ(I, J:WORD):WORD;
            Function BuscSalI(I, J:WORD):WORD;
            Function BuscSalJ(I, J:WORD): WORD;
            Procedure BuscSalida;



    End;

implementation

{ Matriz }

procedure Matriz.AddColumna;
begin
     Inc(NroColumnas);

end;

procedure Matriz.AddFila;
begin
     Inc(NroFilas);
end;




function Matriz.Columnas: Word;
begin
     Result:=NroColumnas;
end;


procedure Matriz.DelColumna(C: Word);
begin

end;

procedure Matriz.DelFila(F: Word);
var
  I: Word;
  j: Integer;
begin
     if (F>0)And(F<=NroFilas) then
     Begin
      for I := F to NroFilas-1 do
        for j := 1 to NroColumnas do
          Celdas[i,j]:=Celdas[i+1,j];
      Dec(NroFilas);
     End
     Else raise Exception.Create('Fila Invalida');
end;

function Matriz.Filas: Word;
begin
     Result:=NroFilas;
end;

procedure Matriz.InsColumna(C: Word);
begin

end;

procedure Matriz.InsFila(F: Word);
var
  I: Word;
  J: Integer;
begin
      if (F>0)And(F<=NroFilas) then
     Begin
          Inc(NroFilas);
          for I := NroFilas downto F+1 do
             for J := 1 to NroColumnas do
                 Celdas[I,J]:=Celdas[I-1,J];
     End
     Else raise Exception.Create('Columna Invalida');

end;


procedure Matriz.ModElement(F, C: Word; E: Real);
begin
     if (F>0)And(F<=NroFilas) And(C>0)And(C<=NroColumnas) then
         Celdas[F,C]:=E
     Else raise Exception.Create('Posicion Invalida');
end;

function Matriz.ObtElement(F, C: Word): Real;
begin
     if (F>0)And(F<=NroFilas) And(C>0)And(C<=NroColumnas) then
         Result:=Celdas[F,C]
     Else raise Exception.Create('Posicion Invalida');
end;

procedure Matriz.Redimensionar(NF, NC: Word);
begin
     NroFilas:=NF;
     NroColumnas:=NC;
end;

function Matriz.SumarElementos: Real;
var
  I,J: Integer;
  Suma : Real;
begin
    Suma:=0;
     for I := 1 to NroFilas do
        for J := 1 to NroColumnas do
            Suma:=Suma+Celdas[i,j];
     Result:=Suma;
end;




function Matriz.BuscElement(E: Real): Boolean;
Var I, J:Word; B: Boolean;
begin
  i:=1;
    while (i<=filas) and (B=false) do
    begin
      j:=1;
      while (j<=columnas) and (B=false) do
      begin
        if Celdas[i,j]=e then
        begin
          B:=true;
        end;
        j:=j+1;
      end;
      i:=i+1;
    end;
    result:=B;

end;





procedure Matriz.CargarMatriz(I, J: WORD; E:Real);              // Ni idea
Var T: Real;
begin
    T:=0;
    for I := NroFilas Downto 1 do
      Begin
        for J := NroColumnas Downto 1 do
        Begin
            Celdas[I,J]:=T;
        End;

      End;
end;


procedure Matriz.CargarMtriz1;
Var I, J:Word;  E:Real;
begin
    E:=1;
    for J :=1  to NroColumnas do
    Begin
        for I := 1 to NroFilas do
        Begin
          Celdas[i, j]:=E;
          E:=E+1;
        End;
    End;
end;





procedure Matriz.MatrizDeFibonacci;
Var E, K, a, b: Integer;  I, J:Word;
begin
  K:=-1; J:= NroColumnas;
  A:=0; B:=1;
      for I := NroFilas Downto 1 do
        Begin
          while (J<=NroColumnas) And (J>0) do
          Begin
              E:=A+B;
              A:=B;   B:=E;
              Celdas[I, J]:=E;
              J:=J+K;
          End;
          K:= K*(-1);
          J:=J+K;
        End;

end;


procedure Matriz.FormaDeCirculo;
Var I, J, NC, NF, C, F: WORD;    E:REAL;
begin
      I:=1;  E:= 1;  C:=NroColumnas; F:=NroFilas; NC:=1; NF:=1;
      for J := NC to C do
      Begin
          Celdas[I, J]:=E;
      End;
      for I := NF to F do
      Begin
          Celdas[I, J]:= E;
      End;
      NC:=NroColumnas; C:=1;
end;



function Matriz.CountDig(E: Real): Byte;
begin
      Result:= Trunc(Log10 (E)) +1;
end;


FuncTion Matriz.BuscarElementoPorFilas(E:Cardinal): Boolean;
Var I, J:Word; B: Boolean;  El, nn, T: Cardinal;      Dig:Byte;
begin
  i:=1;
while (B=False) aND (i<=nROfILAS) do
Begin
      J:=1;
      while (B=False) aND (j<=NroColumnAS) And (El>0) do
        begin

        end;


End;
result:=B;
end;



procedure Matriz.MatrizExamen;
Var I, J, R, c, U: WORD;       E:byte;
begin
    //R:=(NroFilas Mod 2)+1;
    J:=NroColumnas;
    R:=J; c:=1;    E:=1;
    for I := 1 to ((NroFilas Div 2)+1) do
    Begin
      Celdas[i,R]:=E;
      Inc(E);
      if (R=NroColumnas) then
        Begin
            R:=J-(C);
            if R >=((NroColumnas Div 2)+1) then
            Begin
              Celdas[i,R]:=E;
            End;
        End;
        Inc(E);

        while R<>NroColumnas do
        Begin
          Celdas[U,R]:=E;
          Inc(R);
          Inc(U);
        End;
        R:=R+1;
        C:=C+1;
    End;

    J:=1;
    R:=J;
    E:=1;
    c:=1;
    for I := NroFilas  Downto ((NroFilas Div 2)+1) do
    Begin
      Celdas[i,r]:=E;
      Inc(E);
      if (R=1) then
        Begin
            R:=J+(C);
            if R <=((NroFilas Div 2)+1) then
            Begin

              celdas[i,R]:=E;
              Inc(E);
            End;
        End;
        R:=R-1;
        C:=C+1;
    End;




end;


                     //3personaje    2salida       1barrera    0libre

function Matriz.BuscPrI(I, J:WORD): Word;
Var   C:Byte; R:Integer;
begin
    I:=1; J:=1; C:=0;
    While (I<=NroFilas) And (C=0) do
    Begin
        for J := J to NroColumnas do
          Begin
              If Celdas[I,J]=3 then
              Begin
                  C:=1;
                  R:=I;
              End;
          End;
          Inc(I);
          J:=1;
    End;
    Result:=R;
end;

function Matriz.BuscPrJ(I, J:WORD): Word;
Var  C:Byte; R:Integer;
begin
    I:=1; J:=1; C:=0;
    While (I<=NroFilas) And (C=0) do
    Begin
        for J := J to NroColumnas do
          Begin
              If Celdas[I,J]=3 then
              Begin
                  C:=1;
                  R:=J;
              End;
          End;
          Inc(I);
          J:=1;
    End;
    Result:=R;
end;
function Matriz.BuscSalI(I, J:WORD): Word;
Var  C:Byte; R:Integer;
begin
    I:=1; J:=1; C:=0;
    While (I<=NroFilas) And (C=0) do
    Begin
        for J := J to NroColumnas do
          Begin
              If Celdas[I,J]=2 then
              Begin
                  C:=1;
                  R:=I;
              End;
          End;
          Inc(I);
          J:=1;
    End;
    Result:=R;
end;


function Matriz.BuscSalJ(I, J:WORD): Word;
Var C:Byte; R:Integer;
begin
    I:=1; J:=1; C:=0;
    While (I<=NroFilas) And (C=0) do
    Begin
        for J := J to NroColumnas do
          Begin
              If Celdas[I,J]=2 then
              Begin
                  C:=1;
                  R:=J;
              End;
          End;
          Inc(I);
          J:=1;
    End;
    Result:=R;
end;

procedure Matriz.BuscSalida;
Var PerSI, PerJ, SaliI,SalJ, Derecha,Izquierda, Arriba, Abajo, I, J: Word;       Fin:Boolean;
begin
      I:=1; J:=1;
      PerSi:=BuscPrI(I, J); PerJ:= BuscPrJ(I ,J);      Fin:=True;
      SaliI:=BuscSalI(I, J); SalJ:=BuscSalJ(I, J);
      Celdas[PerSi, PerJ]:=8;

      Derecha:=PerJ+1;
      Izquierda:=PerJ-1;
      Arriba:=PerSi-1;
      Abajo:=PersI+1;

      while (Fin=True) do
      Begin
          while (Derecha<=NroColumnas) And (Celdas[PerSi,Derecha]<>1) And (Fin=TRue) do
          Begin
            if (Celdas[PerSi,Derecha]= 2) then
            bEGIN
              Fin:=False;
            end;
            Celdas[PerSi,Derecha]:=8;
            Inc(Derecha);
          End;
          while (Izquierda<=NroColumnas) And (Celdas[PerSi,Izquierda]<>1)And (Fin=TRue) do
          Begin
           if (Celdas[PerSi,Izquierda]= 2) then
            bEGIN
              Fin:=False;
            end;
            Celdas[PerSi,Izquierda]:=8;
            Dec(Izquierda);
          End;
          while (Arriba<=NroFilas) And (Celdas[Arriba, PerJ]<>1) And (Fin=TRue) do
          Begin
             if (Celdas[Arriba, PerJ]= 2) then
            bEGIN
              Fin:=False;
            end;
            Celdas[Arriba, PerJ]:=8;
            Dec(Arriba);
          End;
          while (Abajo<=NroFilas) And (Celdas[Abajo,PerJ]<>1) And (Fin=TRue) do
          Begin
             if (Celdas[Abajo,PerJ]= 2) then
            bEGIN
              Fin:=False;
            end;
            Celdas[Abajo,PerJ]:=8;
            Inc(Abajo);
          End;


      End;

end;

end.
