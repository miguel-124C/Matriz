unit UCMatriz;

interface
Uses SysUtils, Math;
const
     Nf = 128;
     Nc = 128;
Type

    Matriz = Class
      Private
             NroFilas,
             NroColumnas : Word;
             Celdas : Array[1..Nf,1..Nc] Of Real;
      Public
            Procedure Redimensionar(NF,NC:Word);
            Function Filas : Word;
            Function Columnas : Word;
            Function ObtElement(F,C:Word):Real;
            Procedure ModElement(F,C:Word; E:Real);
            Procedure AddFila;
            Procedure AddColumna;
            Procedure InsFila(F:Word);
            Procedure InsColumna(C:Word);
            Procedure DelFila(F:Word);
            Procedure DelColumna(C:Word);
            Function SumarElementos:Real;
            Function BuscElement(E:Real): Boolean;
            Procedure CargarMatriz (I,J: WORD; E: Real);
            Procedure CargarMtriz1 ;
            Procedure MatrizDeFibonacci;
            Procedure FormaDeCirculo;

            Function CountDig(E: Real):Byte;
            Function BuscarElementoPorFilas(E:Cardinal): Boolean;



    End;

implementation

{ Matriz }

procedure Matriz.AddColumna;
begin
     Inc(NroColumnas);

end;

procedure Matriz.AddFila;
begin
     Inc(NroFilas);
end;




function Matriz.Columnas: Word;
begin
     Result:=NroColumnas;
end;


procedure Matriz.DelColumna(C: Word);
begin

end;

procedure Matriz.DelFila(F: Word);
var
  I: Word;
  j: Integer;
begin
     if (F>0)And(F<=NroFilas) then
     Begin
      for I := F to NroFilas-1 do
        for j := 1 to NroColumnas do
          Celdas[i,j]:=Celdas[i+1,j];
      Dec(NroFilas);
     End
     Else raise Exception.Create('Fila Invalida');
end;

function Matriz.Filas: Word;
begin
     Result:=NroFilas;
end;

procedure Matriz.InsColumna(C: Word);
begin

end;

procedure Matriz.InsFila(F: Word);
var
  I: Word;
  J: Integer;
begin
      if (F>0)And(F<=NroFilas) then
     Begin
          Inc(NroFilas);
          for I := NroFilas downto F+1 do
             for J := 1 to NroColumnas do
                 Celdas[I,J]:=Celdas[I-1,J];
     End
     Else raise Exception.Create('Columna Invalida');

end;


procedure Matriz.ModElement(F, C: Word; E: Real);
begin
     if (F>0)And(F<=NroFilas) And(C>0)And(C<=NroColumnas) then
         Celdas[F,C]:=E
     Else raise Exception.Create('Posicion Invalida');
end;

function Matriz.ObtElement(F, C: Word): Real;
begin
     if (F>0)And(F<=NroFilas) And(C>0)And(C<=NroColumnas) then
         Result:=Celdas[F,C]
     Else raise Exception.Create('Posicion Invalida');
end;

procedure Matriz.Redimensionar(NF, NC: Word);
begin
     NroFilas:=NF;
     NroColumnas:=NC;
end;

function Matriz.SumarElementos: Real;
var
  I,J: Integer;
  Suma : Real;
begin
    Suma:=0;
     for I := 1 to NroFilas do
        for J := 1 to NroColumnas do
            Suma:=Suma+Celdas[i,j];
     Result:=Suma;
end;




function Matriz.BuscElement(E: Real): Boolean;
Var I, J:Word; B: Boolean;
begin
  i:=1;
    while (i<=filas) and (B=false) do
    begin
      j:=1;
      while (j<=columnas) and (B=false) do
      begin
        if Celdas[i,j]=e then
        begin
          B:=true;
        end;
        j:=j+1;
      end;
      i:=i+1;
    end;
    result:=B;

end;


procedure Matriz.CargarMatriz(I, J: WORD; E:Real);              // Ni idea
Var T: Real;
begin
    T:=0;
    for I := NroFilas Downto 1 do
      Begin
        for J := NroColumnas Downto 1 do
        Begin
            Celdas[I,J]:=T;
        End;

      End;
end;


procedure Matriz.CargarMtriz1;
Var I, J:Word;  E:Real;
begin
    E:=1;
    for J :=1  to NroColumnas do
    Begin
        for I := 1 to NroFilas do
        Begin
          Celdas[i, j]:=E;
          E:=E+1;
        End;
    End;
end;



procedure Matriz.MatrizDeFibonacci;
Var E, K, a, b: Integer;  I, J:Word;
begin
  K:=-1; J:= NroColumnas;
  A:=0; B:=1;
      for I := NroFilas Downto 1 do
        Begin
          while (J<=NroColumnas) And (J>0) do
          Begin
              E:=A+B;
              A:=B;   B:=E;
              Celdas[I, J]:=E;
              J:=J+K;
          End;
          K:= K*(-1);
          J:=J+K;
        End;

end;


procedure Matriz.FormaDeCirculo;
Var I, J, NC, NF, C, F: WORD;    E:REAL;
begin
      I:=1;  E:= 1;  C:=NroColumnas; F:=NroFilas; NC:=1; NF:=1;
      for J := NC to C do
      Begin
          Celdas[I, J]:=E;
      End;
      for I := NF to F do
      Begin
          Celdas[I, J]:= E;
      End;
      NC:=NroColumnas; C:=1;
end;



function Matriz.CountDig(E: Real): Byte;
begin
      Result:= Trunc(Log10 (E)) +1;
end;


FuncTion Matriz.BuscarElementoPorFilas(E:Cardinal): Boolean;
Var I, J:Word; B: Boolean;  El, nn, T: Cardinal;      Dig:Byte;
begin
  i:=1;
while (B=False) aND (i<=nROfILAS) do
Begin
      J:=1;
      while (B=False) aND (j<=NroColumnAS) And (El>0) do
        begin

        end;


End;
result:=B;
end;

end.
